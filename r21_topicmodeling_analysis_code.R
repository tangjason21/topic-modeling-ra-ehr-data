# -- Package Installation --
options(repos = c(CRAN = "http://cran.us.r-project.org"))
packages_needed <- c("tm", "topicmodels", "reshape2", "ggplot2", "wordcloud", 
                     "pals", "SnowballC", "lda", "ldatuning", "kableExtra", "DT", 
                     "flextable", "remotes", "haven", "rpart", "tidyverse", "statar", 
                     "rdrobust", "sandwich", "lmtest", "tidytext", "caTools", "caret", 
                     "ROCR", "PRROC", "pROC", "writexl", "RColorBrewer", "wordcloud2", "readxl")
new_packages <- packages_needed[!(packages_needed %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)
libraries_needed <- c("haven", "rpart", "tidyverse", "statar", "rdrobust", "sandwich", 
                      "lmtest", "tidytext", "stringr", "topicmodels", "ggplot2", "plyr", 
                      "dplyr", "readr", "caTools", "caret", "ROCR", "PRROC", "pROC", 
                      "writexl", "wordcloud", "RColorBrewer", "wordcloud2", "readxl", 
                      "nnet", "xtable", "flexmix", "ldatuning")
invisible(lapply(libraries_needed, library, character.only = TRUE))

# -- LDA --
# start with a dataframe 'df' with the following columns:
# 'patientid', 'code' (feature like 'Abdominal pain'), and
# 'totalcount' (how many total times the feature appears in the patient's charts)

# Create document-term-matrix
dtm <- df %>%
  cast_dtm(patientid, code, totalcount)
dtm

# -- Produces a BIC curve --
k_values <- seq(2, 20, by=1)
bic_values <- numeric(length(k_values))
for (i in seq_along(k_values)) {
  k <- k_values[i]
  lda_model <- LDA(dtm, k = k)
  bic_values[i] <- BIC(lda_model)
}
bic_df <- data.frame(k = k_values, BIC = bic_values)

# BIC plot (over k)
ggplot(bic_df, aes(x = k, y = BIC)) +
  geom_line() +
  geom_point() +
  labs(title = "BIC over k",
       x = "Number of Topics (k)",
       y = "BIC") +
  theme_minimal()


# -- Run LDA with specified number of topics k --
k_topics = 4
lda_model <- LDA(dtm, k = k_topics, control = list(seed = 8)) 

# -- Construct visualization of word topic scores --

# Note that 'beta' corresponds to word topic scores and
# 'gamma' corresponds to document topic scores

lda_topics <- tidy(lda_model, matrix = "beta")
colnames(lda_topics) <- c("topic", "code", "beta")
lda_topics <- lda_topics %>% drop_na(beta)

# If we'd like to construct a weighted version of word topic score
# by weighting by how often a feature generally shows up, we need
# a dataframe 'codefrequency' which counts how often the code shows up
# across all patients

lda_topics <- merge(lda_topics, codefrequency, by=c("code"))
lda_topics$weight <- lda_topics$beta * lda_topics$freq

# For each topic generated by LDA, plot top 20 features by word topic score
for (t in unique(lda_topics$topic)) {
  topic_data <- lda_topics %>% filter(topic == t) %>% arrange(desc(beta))
  topic_data <- topic_data[1:20,]
  ggplot(topic_data, aes(x = reorder(code, beta), y = beta)) +
    geom_bar(stat = "identity", fill = "blue") +
    coord_flip() +
    labs(title = paste("Top Word Topic Scores for LDA Topic", t),
         x = "Feature", y = "Word Topic Score") +
    theme_minimal()
}

# -- Run multinomial regressions for each LDA topic --
# Run over all patients, controlling for demographics
# Predictor: document topic score for this particular LDA topic
# Outcome: Future treatment course cluster (e.g., TNFi persister, abatacept, etc.)

# Utilizes a demographics dataframe 'demdata' and a true labels dataframe
# 'clusterlabels' which lists the true future treatment course cluster for
# each patient

for(i in 1:k_topics){
  # Subset gamma matrix for the current topic
  # (Recall 'gamma' represents document topic score)
  subset_gamma <- gamma_matrix[gamma_matrix$topic == i, ]
  colnames(subset_gamma) <- c("patientid", "topic", "gamma")
  
  # Merge with additional data frames
  subset_gamma <- merge(subset_gamma, demdata, by="patientid")
  subset_gamma <- merge(subset_gamma, clusterlabels, by="patientid")
  
  # Relevel cluster (true label) factor and set baseline as 1
  subset_gamma$cluster <- relevel(as.factor(subset_gamma$cluster), ref = 1)
  
  # Split the data into training and testing sets
  spl <- sample.split(subset_gamma$cluster, SplitRatio = 0.8)
  train <- subset(subset_gamma, spl == TRUE)
  test <- subset(subset_gamma, spl == FALSE)
  
  # Multinomial logistic regression model
  # Adjust for covariates available in demographics dataset
  association_model <- multinom(cluster ~ gamma + age + factor(year) + 
                                  factor(female) + factor(black) + 
                                  factor(hispanic) + factor(other), data = train)
  
  exp_association_model <- exp(coef(association_model))
  z <- summary(association_model)$coefficients / summary(association_model)$standard.errors
  p <- (1 - pnorm(abs(z), 0, 1)) * 2
  
  # Results
  print(association_model)
  print(summary(association_model)$standard.errors)
  print(exp_association_model)
  print(p)
  
  # Predict on the test set
  predicted <- predict(association_model, newdata = test, "probs")
  print(predicted)
}